# Define the transformation matrix
# We'll create a transformation that shifts the image by 100 pixels in the x-direction and 50 pixels in the y-direction
transformation_matrix = np.float32([[1, 0, 100], [0, 1, 50]])

# Apply the affine transformation
rows, cols = image.shape[:2]
transformed_image = cv2.warpAffine(image, transformation_matrix, (cols, rows))

# Plot the original and transformed images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.title('Original Image')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(cv2.cvtColor(transformed_image, cv2.COLOR_BGR2RGB))
plt.title('Transformed Image')
plt.axis('off')

plt.show()
This code will load an image from a URL, apply an affine transformation to shift the image by 100 pixels in the x-direction and 50 pixels in the y-direction, and then display both the original and transformed images side by side.



User
Translation: Shifting an image along the x and/or y axis.
Rotation: Rotating an image around a center point.
Scaling: Resizing an image
Shearing: Slanting an image along an axis.
perform all 
ChatGPT
Sure! Below is an example demonstrating translation, rotation, scaling, and shearing using OpenCV in Google Colab:

python
Copy code
import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
image_path = "https://raw.githubusercontent.com/openai/gpt-3.5-turbo/main/content/blog/images/OpenAI_logo.png"
image = cv2.imread(image_path)

# Define transformation parameters
# Translation (shifting along x and y axis)
translation_matrix = np.float32([[1, 0, 100], [0, 1, 50]])

# Rotation (rotating around the center)
rows, cols = image.shape[:2]
rotation_angle = 45
rotation_center = (cols / 2, rows / 2)
rotation_matrix = cv2.getRotationMatrix2D(rotation_center, rotation_angle, 1)

# Scaling (resizing)
scaling_factor_x = 1.5
scaling_factor_y = 1.5
scaling_matrix = np.float32([[scaling_factor_x, 0, 0], [0, scaling_factor_y, 0]])

# Shearing (slanting along x-axis)
shearing_matrix = np.float32([[1, 0.5, 0], [0, 1, 0]])

# Apply transformations
translated_image = cv2.warpAffine(image, translation_matrix, (cols, rows))
rotated_image = cv2.warpAffine(image, rotation_matrix, (cols, rows))
scaled_image = cv2.warpAffine(image, scaling_matrix, (int(cols * scaling_factor_x), int(rows * scaling_factor_y)))
sheared_image = cv2.warpAffine(image, shearing_matrix, (cols, rows))

# Plot the original and transformed images
plt.figure(figsize=(15, 10))

plt.subplot(2, 3, 1)
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.title('Original Image')
plt.axis('off')

plt.subplot(2, 3, 2)
plt.imshow(cv2.cvtColor(translated_image, cv2.COLOR_BGR2RGB))
plt.title('Translated Image')
plt.axis('off')

plt.subplot(2, 3, 3)
plt.imshow(cv2.cvtColor(rotated_image, cv2.COLOR_BGR2RGB))
plt.title('Rotated Image')
plt.axis('off')

plt.subplot(2, 3, 4)
plt.imshow(cv2.cvtColor(scaled_image, cv2.COLOR_BGR2RGB))
plt.title('Scaled Image')
plt.axis('off')

plt.subplot(2, 3, 5)
plt.imshow(cv2.cvtColor(sheared_image, cv2.COLOR_BGR2RGB))
plt.title('Sheared Image')
plt.axis('off')

plt.show()
